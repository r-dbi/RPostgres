% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PqConnection.R
\name{postgresWaitForNotify}
\alias{postgresWaitForNotify}
\title{Wait for and return any notifications that return within timeout}
\usage{
postgresWaitForNotify(conn, timeout = 1)
}
\arguments{
\item{conn}{a \linkS4class{PqConnection} object, produced by
\code{\link[DBI:dbConnect]{DBI::dbConnect()}}}

\item{timeout}{How long to wait, in seconds. Default 1}
}
\value{
If a notification was available, a list of:
\describe{
\item{channel}{Name of channel}
\item{pid}{PID of notifying server process}
\item{payload}{Content of notification}
}
If no notifications are available, return NULL
}
\description{
Once you subscribe to notifications with LISTEN, use this to wait for
responses on each channel.
}
\examples{
# For running the examples on systems without PostgreSQL connection:
if (postgresHasDefault()) {
    library(DBI)
    library(callr)

    # listen for messages on the grapevine
    db_listen <- dbConnect(RPostgres::Postgres())
    dbExecute(db_listen, "LISTEN grapevine")

    # Start another process, which sends a message after a delay
    rp <- r_bg(function () {
        library(DBI)
        Sys.sleep(0.3)
        db_notify <- dbConnect(RPostgres::Postgres())
        dbExecute(db_notify, "NOTIFY grapevine, 'psst'")
        dbDisconnect(db_notify)
    })

    # Sleep until we get the message
    n <- NULL
    while (is.null(n)) {
        n <- RPostgres::postgresWaitForNotify(db_listen, 60)
    }
    stopifnot(n$payload == 'psst')

    # Tidy up
    rp$wait()
    dbDisconnect(db_listen)
}
}
